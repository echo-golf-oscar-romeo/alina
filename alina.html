<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Countdown & Reunion Wires</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">

    <!-- Ubuntu Mono -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{
            font-family:"Ubuntu Mono",ui-monospace,Menlo,Consolas,monospace;
            background:#222222;
            color:#dddddd;
            min-height:100vh;
            display:flex;
            flex-direction:column;
            align-items:center;
            justify-content:center;
            gap:1.25rem;
            transition: background-color 0.3s, color 0.3s;
        }

        .top-panel{
            display:flex;
            flex-direction:column;
            align-items:center;
            gap:0.5rem;
        }

        #countdown{
            font-size:clamp(2rem,4.5vw,3rem);
            font-weight:400;
            font-variant-numeric:tabular-nums;
        }

        .mode-toggle{
            display:flex;
            align-items:center;
            gap:0.5rem;
            font-size:0.9rem;
            opacity:0.85;
        }

        .mode-toggle button{
            padding:0.25rem 0.75rem;
            background:currentColor;
            opacity:0.2;
            color:currentColor;
            border-radius:999px;
            border:1px solid currentColor;
            border-opacity:0.3;
            cursor:pointer;
        }
        .mode-toggle button.active{
            opacity:1;
        }

        #canvas-container{
            width:94vw;
            max-width:1000px;
        }
        canvas{
            width:100%;
            height:100%;
            border-radius:10px;
            background:#262626;
            display:block;
        }
    </style>
</head>
<body>
<div class="top-panel">
    <div id="countdown">--d --h --m --s</div>
    <div class="mode-toggle">
        <button id="mode-time" class="active">countdown</button>
        <button id="mode-percent">% left</button>
    </div>
</div>

<div id="canvas-container">
    <canvas id="canvas"></canvas>
</div>

<script>
/* ---------- TIME CONSTANTS (UTC+8) ---------- */
function inTzOffset(dateStr, offsetHours){
    const d = new Date(dateStr + ':00');
    const localOffset = d.getTimezoneOffset()/60;
    const diff = offsetHours + localOffset;
    return new Date(d.getTime() - diff*3600*1000);
}

const TZ = 8;
const TARGET = inTzOffset('2026-01-11T16:45',TZ);

const START_GLOBAL = inTzOffset('2025-12-25T18:00',TZ);
const END_GLOBAL   = TARGET;

const START_BOTTOM_ABS = inTzOffset('2025-12-25T18:00',TZ);
const END_BOTTOM_ABS   = inTzOffset('2026-01-02T23:00',TZ);

const START_TOP_ABS    = inTzOffset('2025-12-31T16:00',TZ);
const END_TOP_ABS      = TARGET;

// Expand timeline to show Dec 21 to Jan 15
const TIMELINE_START = inTzOffset('2025-12-21T00:00',TZ);
const TIMELINE_END   = inTzOffset('2026-01-15T00:00',TZ);
const TOTAL_DURATION = TIMELINE_END - TIMELINE_START;

const BOTTOM_DURATION = END_BOTTOM_ABS - START_BOTTOM_ABS;
const TOP_DURATION    = END_TOP_ABS   - START_TOP_ABS;

/* ---------- COUNTDOWN / PERCENT SWITCH ---------- */
let mode = 'time';

const countdownEl = document.getElementById('countdown');
const btnTime = document.getElementById('mode-time');
const btnPercent = document.getElementById('mode-percent');

btnTime.onclick = () => { mode='time'; btnTime.classList.add('active'); btnPercent.classList.remove('active'); };
btnPercent.onclick = () => { mode='percent'; btnPercent.classList.add('active'); btnTime.classList.remove('active'); };

function updateCountdown(){
    const now = new Date();
    if(mode === 'time'){
        let delta = TARGET - now;
        if(delta < 0){ delta = 0; }
        const totalSeconds = Math.floor(delta/1000);
        const days = Math.floor(totalSeconds/86400);
        const hours = Math.floor((totalSeconds%86400)/3600);
        const mins = Math.floor((totalSeconds%3600)/60);
        const secs = totalSeconds%60;
        countdownEl.textContent =
            `${String(days).padStart(2,'0')}d `+
            `${String(hours).padStart(2,'0')}h `+
            `${String(mins).padStart(2,'0')}m `+
            `${String(secs).padStart(2,'0')}s`;
    }else{
        const total = END_GLOBAL - START_GLOBAL;
        const done = Math.max(0, Math.min(total, now - START_GLOBAL));
        const pctLeft = 100 - (done/total)*100;
        countdownEl.textContent = `${pctLeft.toFixed(1)}%`;
    }
    updateTheme();
}

/* ---------- DYNAMIC THEME ---------- */
function updateTheme(){
    const now = new Date();
    const total = END_GLOBAL - START_GLOBAL;
    const done = Math.max(0, Math.min(total, now - START_GLOBAL));
    const progress = done / total; // 0..1
    
    // Interpolate from #222222 (dark) to #f0f0f0 (almost white)
    const startR = 0x22, startG = 0x22, startB = 0x22;
    const endR = 0xf0, endG = 0xf0, endB = 0xf0;
    
    const r = Math.round(startR + (endR - startR) * progress);
    const g = Math.round(startG + (endG - startG) * progress);
    const b = Math.round(startB + (endB - startB) * progress);
    
    const bgColor = `rgb(${r},${g},${b})`;
    document.body.style.backgroundColor = bgColor;
    
    // Text color: dark if light background, light if dark background
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    const textColor = brightness > 128 ? '#222222' : '#dddddd';
    document.body.style.color = textColor;
    
    // Update button styles
    const buttons = document.querySelectorAll('.mode-toggle button');
    buttons.forEach(btn => {
        btn.style.color = textColor;
        btn.style.borderColor = textColor;
    });
}

/* ---------- COLORS ---------- */
function randomBrightPair(){
    const h1 = Math.floor(Math.random()*360);
    const h2 = (h1 + 120 + Math.floor(Math.random()*60))%360;
    const s1 = 70 + Math.random()*25;
    const s2 = 70 + Math.random()*25;
    const l  = 55 + Math.random()*15;
    return [
        `hsl(${h1},${s1}%,${l}%)`,
        `hsl(${h2},${s2}%,${l}%)`
    ];
}
const [colorTop,colorBottom] = randomBrightPair();
const colorTopGray    = 'hsl(0,0%,55%)';
const colorBottomGray = 'hsl(0,0%,55%)';

/* ---------- CANVAS ---------- */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvas-container');

function resizeCanvas(){
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const desiredH = Math.min(vh*0.55, 500);
    container.style.height = desiredH + 'px';

    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    drawScene();
}
window.addEventListener('resize', resizeCanvas);

/* Helper: map time to x */
function timeToX(t, width){
    const clamped = Math.min(TIMELINE_END, Math.max(TIMELINE_START,t));
    return ((clamped - TIMELINE_START)/TOTAL_DURATION)*width;
}

/* Subtle smoothing helper */
function smoothPoint(p1, p2, p3){
    return {
        x: (p1.x + p2.x + p3.x) / 3,
        y: (p1.y + p2.y + p3.y) / 3
    };
}

/* Core drawing for one wire with perfect half-circle arc */
function drawWire(opts){
    const {
        yBase,
        colorMain,
        colorFuture,
        startAbs,
        endAbs,
        now,
        isTop,
        arcRadiusTime,
        width,
        height
    } = opts;

    const globalStart = TIMELINE_START;
    const globalEnd   = TIMELINE_END;
    const globalDuration = globalEnd - globalStart;

    const startX = 0;
    const endX   = width;

    // Absence interval mapped to timeline parameter
    const tAbsStart = (startAbs - globalStart)/globalDuration;
    const tAbsEnd   = (endAbs   - globalStart)/globalDuration;
    const tAbsMid   = (tAbsStart + tAbsEnd)/2;

    // Arc radius in pixels: half of absence duration, then 1.5x smaller
    const radiusFrac = arcRadiusTime / globalDuration;
    const arcRadiusPx = (radiusFrac * width) / 1.5;

    // Arc center X at midpoint
    const arcCenterX = startX + (endX-startX)*tAbsMid;

    // path in parameter t âˆˆ [0,1]
    function path(t){
        const x = startX + (endX-startX)*t;
        let y = yBase;

        if(t > tAbsStart && t < tAbsEnd){ 
            // half-circle arc (REVERSED)
            const rel = (t - tAbsStart)/(tAbsEnd - tAbsStart); // 0..1
            
            if(isTop){
                // Top arc points DOWN (reversed): arc goes below the baseline
                const arcCenterY = yBase + arcRadiusPx;
                const angle = Math.PI * (1 - rel);
                y = arcCenterY - arcRadiusPx * Math.sin(angle);
            }else{
                // Bottom arc points UP (reversed): arc goes above the baseline
                const arcCenterY = yBase - arcRadiusPx;
                const angle = Math.PI * (1 - rel);
                y = arcCenterY + arcRadiusPx * Math.sin(angle);
            }
        }

        return {x,y};
    }

    function strokeSegment(t0,t1,color){
        const steps = 300;
        ctx.beginPath();
        let lastPoint = null;
        for(let i=0;i<=steps;i++){
            const t = t0 + (t1-t0)*i/steps;
            let p = path(t);
            
            // Subtle smoothing: use neighbor points
            if(i > 0 && i < steps){
                const prevT = t0 + (t1-t0)*(i-1)/steps;
                const nextT = t0 + (t1-t0)*(i+1)/steps;
                const pPrev = path(prevT);
                const pNext = path(nextT);
                p = smoothPoint(pPrev, p, pNext);
            }
            
            if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
        }
        ctx.strokeStyle = color;
        ctx.stroke();
    }

    const tNow = (now - globalStart)/globalDuration;
    const tSplit = Math.max(0, Math.min(1, tNow));

    ctx.lineWidth = 3;
    ctx.lineCap = 'round';

    // main colored part
    ctx.shadowColor = colorMain;
    ctx.shadowBlur = 6;
    strokeSegment(0, tSplit, colorMain);

    // future part with weaker glow
    ctx.shadowBlur = 2;
    strokeSegment(tSplit, 1, colorFuture);

    // glowing current marker
    const pAtNow = path(tSplit);
    let markerPos = pAtNow;
    if(tSplit > 0 && tSplit < 1){
        const pPrev = path(Math.max(0, tSplit - 0.01));
        const pNext = path(Math.min(1, tSplit + 0.01));
        markerPos = smoothPoint(pPrev, pAtNow, pNext);
    }
    
    const markerRadius = Math.max(4, Math.min(7, width*0.005));
    const g = ctx.createRadialGradient(markerPos.x,markerPos.y,0,markerPos.x,markerPos.y,markerRadius*1.4);
    g.addColorStop(0,'rgba(255,255,255,0.92)');
    g.addColorStop(0.6,'rgba(255,255,255,0.45)');
    g.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(markerPos.x,markerPos.y,markerRadius*1.4,0,Math.PI*2);
    ctx.fill();

    ctx.shadowBlur = 0;
}

function drawScene(){
    const width  = canvas.width / (window.devicePixelRatio||1);
    const height = canvas.height / (window.devicePixelRatio||1);
    ctx.clearRect(0,0,width,height);

    const nowRaw = new Date();
    const now =
        nowRaw < TIMELINE_START ? TIMELINE_START :
        nowRaw > TIMELINE_END   ? TIMELINE_END   : nowRaw;

    // Significantly closer together
    const centerY = height*0.5;
    const offset  = height*0.12;

    const bottomRadiusTime = BOTTOM_DURATION/2;
    const topRadiusTime    = TOP_DURATION/2;

    ctx.lineJoin = 'round';

    drawWire({
        yBase: centerY + offset,
        colorMain: colorBottom,
        colorFuture: colorBottomGray,
        startAbs: START_BOTTOM_ABS,
        endAbs: END_BOTTOM_ABS,
        now,
        isTop:false,
        arcRadiusTime: bottomRadiusTime,
        width,
        height
    });

    drawWire({
        yBase: centerY - offset,
        colorMain: colorTop,
        colorFuture: colorTopGray,
        startAbs: START_TOP_ABS,
        endAbs: END_TOP_ABS,
        now,
        isTop:true,
        arcRadiusTime: topRadiusTime,
        width,
        height
    });
}

/* ---------- LOOPS ---------- */
resizeCanvas();
updateCountdown();
setInterval(updateCountdown,1000);
setInterval(drawScene,1000);
</script>
</body>
</html>


