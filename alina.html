<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Countdown & Reunion Wires</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">

    <!-- Ubuntu Mono -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{
            font-family:"Ubuntu Mono",ui-monospace,Menlo,Consolas,monospace;
            background:#222222;
            color:#dddddd;
            min-height:100vh;
            display:flex;
            flex-direction:column;
            align-items:center;
            justify-content:center;
            gap:1.5rem;
        }

        .top-panel{
            display:flex;
            flex-direction:column;
            align-items:center;
            gap:0.5rem;
        }

        #countdown{
            font-size:clamp(2.4rem,5vw,3.2rem);
            font-weight:400;
            font-variant-numeric:tabular-nums;
        }

        .mode-toggle{
            display:flex;
            align-items:center;
            gap:0.5rem;
            font-size:0.9rem;
            opacity:0.85;
        }

        .mode-toggle button{
            padding:0.25rem 0.75rem;
            background:#333333;
            color:#dddddd;
            border-radius:999px;
            border:1px solid #444444;
            cursor:pointer;
        }
        .mode-toggle button.active{
            background:#dddddd;
            color:#222222;
        }

        #canvas-container{
            width:90vw;
            max-width:900px;
            height:55vh;
            max-height:420px;
        }
        canvas{
            width:100%;
            height:100%;
            border-radius:10px;
            background:#262626;
        }
    </style>
</head>
<body>
<div class="top-panel">
    <div id="countdown">--:--:--</div>
    <div class="mode-toggle">
        <span>view:</span>
        <button id="mode-time" class="active">time left</button>
        <button id="mode-percent">percent done</button>
    </div>
</div>

<div id="canvas-container">
    <canvas id="canvas"></canvas>
</div>

<script>
/* ---------- TIME CONSTANTS (ALL IN UTC+8) ---------- */
function inTzOffset(dateStr, offsetHours){
    // create date as if in given offset
    const d = new Date(dateStr + ':00'); // assume local ISO without offset
    const localOffset = d.getTimezoneOffset()/60;
    const diff = offsetHours + localOffset;
    return new Date(d.getTime() - diff*3600*1000);
}

// timeline and important moments in UTC+8
const TZ = 8;
const TARGET = inTzOffset('2026-01-11T16:45',TZ);
const START_GLOBAL = inTzOffset('2025-12-25T18:00',TZ);              // global start for % mode
const END_GLOBAL   = TARGET;                                         // global end for % mode

const START_BOTTOM_ABS = inTzOffset('2025-12-25T18:00',TZ);
const END_BOTTOM_ABS   = inTzOffset('2026-01-02T23:00',TZ);

const START_TOP_ABS    = inTzOffset('2025-12-31T16:00',TZ);
const END_TOP_ABS      = TARGET;

const TIMELINE_START = START_BOTTOM_ABS;
const TIMELINE_END   = TARGET;
const TOTAL_DURATION = TIMELINE_END - TIMELINE_START;

const BOTTOM_DURATION = END_BOTTOM_ABS - START_BOTTOM_ABS; // 8 days → radius 4 units
const TOP_DURATION    = END_TOP_ABS   - START_TOP_ABS;

/* ---------- COUNTDOWN / PERCENT SWITCH ---------- */
let mode = 'time'; // 'time' or 'percent'

const countdownEl = document.getElementById('countdown');
const btnTime = document.getElementById('mode-time');
const btnPercent = document.getElementById('mode-percent');

btnTime.onclick = () => { mode='time'; btnTime.classList.add('active'); btnPercent.classList.remove('active'); };
btnPercent.onclick = () => { mode='percent'; btnPercent.classList.add('active'); btnTime.classList.remove('active'); };

function updateCountdown(){
    const now = new Date();
    if(mode === 'time'){
        const delta = TARGET - now;
        if(delta <= 0){
            countdownEl.textContent = '00:00:00';
            return;
        }
        const s = Math.floor(delta/1000);
        const h = Math.floor(s/3600);
        const m = Math.floor((s%3600)/60);
        const sec = s%60;
        countdownEl.textContent =
            `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
    }else{
        const total = END_GLOBAL - START_GLOBAL;
        const done = Math.max(0, Math.min(total, now - START_GLOBAL));
        const pct = (done/total)*100;
        countdownEl.textContent = `${pct.toFixed(1)}%`;
    }
}

/* ---------- COLORS ---------- */
function randomBrightPair(){
    const h1 = Math.floor(Math.random()*360);
    const h2 = (h1 + 120 + Math.floor(Math.random()*60))%360;
    const s1 = 70 + Math.random()*25;
    const s2 = 70 + Math.random()*25;
    const l  = 55 + Math.random()*15;
    return [
        `hsl(${h1},${s1}%,${l}%)`,
        `hsl(${h2},${s2}%,${l}%)`
    ];
}
const [colorTop,colorBottom] = randomBrightPair();
const colorTopGray    = 'hsl(0,0%,55%)';
const colorBottomGray = 'hsl(0,0%,55%)';

/* ---------- CANVAS DRAWING ---------- */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * window.devicePixelRatio;
    canvas.height = rect.height * window.devicePixelRatio;
    ctx.setTransform(window.devicePixelRatio,0,0,window.devicePixelRatio,0,0);
    drawScene();
}
window.addEventListener('resize', resizeCanvas);

/* Parametric piecewise line: straight → half circle → sin/cos */
function drawWire(opts){
    const {
        yBase,
        colorMain,
        colorFuture,
        startAbs,
        endAbs,
        globalStart,
        globalEnd,
        radiusTime,      // in ms (half of absence length)
        now,
        isTop
    } = opts;

    const width = canvas.width / window.devicePixelRatio;
    const height = canvas.height / window.devicePixelRatio;

    const globalDuration = globalEnd - globalStart;

    // map time to x in [0,width]
    function tToX(t){
        const clamped = Math.min(globalEnd, Math.max(globalStart,t));
        return ((clamped - globalStart)/globalDuration)*width;
    }

    const startX = tToX(globalStart);
    const endX   = tToX(globalEnd);

    // absence interval
    const absStart = startAbs;
    const absEnd   = endAbs;
    const absMid   = new Date(absStart.getTime() + (absEnd-absStart)/2);

    const absRadiusMs = radiusTime;
    const absRadiusDayFraction = absRadiusMs / globalDuration;
    const arcRadiusPx = (endX-startX) * absRadiusDayFraction;

    const nowX = tToX(now);

    // helper for color split: draw piecewise up to current
    function strokePath(pathFn, t0, t1){
        const steps = 300;
        function segmentStroke(tA,tB,color){
            ctx.beginPath();
            for(let i=0;i<=steps;i++){
                const tt = tA + (tB-tA)*i/steps;
                const {x,y} = pathFn(tt);
                if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
            ctx.strokeStyle = color;
            ctx.stroke();
        }
        const tNow = (now - globalStart)/globalDuration;
        const tStart = t0;
        const tEnd = t1;
        const tSplit = Math.max(tStart, Math.min(tEnd, tNow));

        if(tSplit>tStart){
            segmentStroke(tStart,tSplit,colorMain);
        }
        if(tEnd>tSplit){
            segmentStroke(tSplit,tEnd,colorFuture);
        }
    }

    // Build path func: piecewise
    const tAbsStart = (absStart - globalStart)/globalDuration;
    const tAbsMid   = (absMid   - globalStart)/globalDuration;
    const tAbsEnd   = (absEnd   - globalStart)/globalDuration;

    const sinStartT = tAbsMid; // after top of arc
    const sinEndT   = 1;

    const baseAmp = (canvas.height / window.devicePixelRatio)*0.06;
    const sinFreq = 8*Math.PI; // total phase

    function path(t){
        const x = startX + (endX-startX)*t;
        let y = yBase;

        if(t<tAbsStart){ // straight
            y = yBase;
        }else if(t<tAbsEnd){ // half circle
            const a = (t - tAbsStart)/(tAbsEnd - tAbsStart); // 0..1
            const angle = isTop
                ? Math.PI + a*Math.PI   // upper arc
                : 0 + a*Math.PI;        // lower arc
            const cx = startX + (endX-startX)*((tAbsStart+tAbsEnd)/2);
            const cy = isTop ? yBase - arcRadiusPx : yBase + arcRadiusPx;
            y = cy + arcRadiusPx*Math.sin(angle);
        }else{ // intertwining sin/cos
            const u = (t - sinStartT)/(sinEndT - sinStartT);
            const phase = sinFreq*u;
            const amp = baseAmp;
            if(isTop){
                y = yBase - Math.sin(phase)*amp;
            }else{
                y = yBase + Math.cos(phase)*amp;
            }
        }
        return {x,y};
    }

    ctx.lineWidth = 3;
    ctx.lineCap = 'round';

    strokePath(path,0,1);

    // glowing mark at the end of colored part (same x for both wires)
    const markerX = nowX;
    const {y: yAtNow} = path((now - globalStart)/globalDuration);
    const gradient = ctx.createRadialGradient(markerX,yAtNow,0,markerX,yAtNow,16);
    gradient.addColorStop(0,'rgba(255,255,255,0.9)');
    gradient.addColorStop(0.4,'rgba(255,255,255,0.4)');
    gradient.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(markerX,yAtNow,16,0,Math.PI*2);
    ctx.fill();
}

function drawScene(){
    const width = canvas.width / window.devicePixelRatio;
    const height = canvas.height / window.devicePixelRatio;
    ctx.clearRect(0,0,width,height);

    const now = new Date();
    const nowClamped = now < TIMELINE_START ? TIMELINE_START :
                       now > TIMELINE_END   ? TIMELINE_END   : now;

    const centerY = height*0.5;
    const offsetY = height*0.14;

    // radiusTime = half of absence duration
    const bottomRadiusTime = (END_BOTTOM_ABS - START_BOTTOM_ABS)/2;
    const topRadiusTime    = (END_TOP_ABS   - START_TOP_ABS)/2;

    ctx.shadowBlur = 8;
    ctx.shadowColor = colorBottom;
    drawWire({
        yBase: centerY + offsetY,
        colorMain: colorBottom,
        colorFuture: colorBottomGray,
        startAbs: START_BOTTOM_ABS,
        endAbs: END_BOTTOM_ABS,
        globalStart: TIMELINE_START,
        globalEnd: TIMELINE_END,
        radiusTime: bottomRadiusTime,
        now: nowClamped,
        isTop:false
    });

    ctx.shadowColor = colorTop;
    drawWire({
        yBase: centerY - offsetY,
        colorMain: colorTop,
        colorFuture: colorTopGray,
        startAbs: START_TOP_ABS,
        endAbs: END_TOP_ABS,
        globalStart: TIMELINE_START,
        globalEnd: TIMELINE_END,
        radiusTime: topRadiusTime,
        now: nowClamped,
        isTop:true
    });

    ctx.shadowBlur = 0;
}

/* ---------- LOOPS ---------- */
resizeCanvas();
updateCountdown();
setInterval(updateCountdown,1000);
setInterval(drawScene,1000);
</script>
</body>
</html>
